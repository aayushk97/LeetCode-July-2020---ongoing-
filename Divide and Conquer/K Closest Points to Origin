//We find the dist of points from origin and then put them in a max heap so that when elements are more than k we pop. 
//IN the end we have least dist points. We then return this in array.

class Solution {
public:
    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {
        priority_queue<pair<float, int>> pq;
        
        for(int i = 0; i < points.size(); i++){
            
            float dist = calculateDist(points[i]);
            
            pq.push({dist, i});
            if(pq.size() > k) pq.pop();
        }
        
        vector<vector<int>> result;
        
        while(pq.size()){
            pair<int, int> curr = pq.top();
            pq.pop();
            result.push_back(points[curr.second]);
        }
        
        return result;
    }
    
    float calculateDist(vector<int>& point){
        return sqrt(point[0]*point[0] + point[1]*point[1]);
    }
};
